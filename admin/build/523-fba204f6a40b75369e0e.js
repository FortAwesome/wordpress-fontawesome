"use strict";(self.webpackChunkfont_awesome_admin=self.webpackChunkfont_awesome_admin||[]).push([[523],{7523:(e,t,n)=>{n.d(t,{s:()=>c});var o=n(6677),s=n.n(o);const l=e=>{if("undefined"==typeof document)return!0;{const t="on"+e;let n=t in document;if(!n){const e=document.createElement("div");e.setAttribute(t,"return;"),n="function"==typeof e[t]}return n}},a=(e,t,n)=>{const o=e.__events||(e.__events={}),s=o[t];s&&e.removeEventListener(t,s),e.addEventListener(t,o[t]=function(e){n&&n.call(this,e)})},r=e=>{const t=new Map;return e.forEach((e=>t.set(e,e))),t},i=(...e)=>t=>{e.forEach((e=>{((e,t)=>{"function"==typeof e?e(t):null!=e&&(e.current=t)})(e,t)}))};const $=(e,t,n,$)=>{void 0!==$&&$();const d=e.toLowerCase().split("-").map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join(""),c=class extends s().Component{constructor(e){super(e),this.setComponentElRef=e=>{this.componentEl=e}}componentDidMount(){this.componentDidUpdate(this.props)}componentDidUpdate(e){((e,t,n={})=>{if(e instanceof Element){const o=((e,t,n)=>{const o=t.className||t.class,s=n.className||n.class,l=r(e),a=r(o?o.split(" "):[]),i=r(s?s.split(" "):[]),$=[];return l.forEach((e=>{a.has(e)?($.push(e),a.delete(e)):i.has(e)||$.push(e)})),a.forEach((e=>$.push(e))),$.join(" ")})(e.classList,t,n);""!==o&&(e.className=o),Object.keys(t).forEach((n=>{if("children"!==n&&"style"!==n&&"ref"!==n&&"class"!==n&&"className"!==n&&"forwardedRef"!==n)if(0===n.indexOf("on")&&n[2]===n[2].toUpperCase()){const o=n.substring(2),s=o[0].toLowerCase()+o.substring(1);l(s)||a(e,s,t[n])}else e[n]=t[n],"string"==typeof t[n]&&e.setAttribute(n.replace(/([A-Z])/g,(e=>`-${e[0].toLowerCase()}`)),t[n])}))}})(this.componentEl,this.props,e)}render(){const t=this.props,{children:s,forwardedRef:a,style:r,className:$,ref:d}=t,c=function(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n}(t,["children","forwardedRef","style","className","ref"]);let m=Object.keys(c).reduce(((e,t)=>{if(0===t.indexOf("on")&&t[2]===t[2].toUpperCase()){const n=t.substring(2).toLowerCase();"undefined"!=typeof document&&l(n)&&(e[t]=c[t])}else e[t]=c[t];return e}),{});n&&(m=n(this.props,m));const h=Object.assign(Object.assign({},m),{ref:i(a,this.setComponentElRef),style:r});return(0,o.createElement)(e,h,s)}static get displayName(){return d}};return t&&(c.contextType=t),((e,t)=>{const n=(t,n)=>s().createElement(e,Object.assign({},t,{forwardedRef:n}));return n.displayName=t,s().forwardRef(n)})(c,d)};var d=n(858);!function(){if("undefined"!=typeof window&&void 0!==window.Reflect&&void 0!==window.customElements){var e=HTMLElement;window.HTMLElement=function(){return Reflect.construct(e,[],this.constructor)},HTMLElement.prototype=e.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,e)}}(),"undefined"==typeof window?Promise.resolve():(!d.B.cssVarShim||d.C&&d.C.supports&&d.C.supports("color","var(--c)")?(0,d.a)():n.e(755).then(n.t.bind(n,9512,23)).then((()=>(d.p.$cssShim$=d.w.__cssshim)?d.p.$cssShim$.i():0))).then((()=>(0,d.b)([["fa-icon",[[0,"fa-icon",{name:[1],stylePrefix:[1,"style-prefix"],familyStylePathSegment:[1,"family-style-path-segment"],svgApi:[8,"svg-api"],pro:[4],iconUpload:[16],class:[1],svgFetchBaseUrl:[1,"svg-fetch-base-url"],getUrlText:[16],kitToken:[1,"kit-token"],icon:[16],size:[1],loading:[32],iconDefinition:[32]}]]],["fa-icon-chooser",[[1,"fa-icon-chooser",{kitToken:[1,"kit-token"],version:[1],searchInputPlaceholder:[1,"search-input-placeholder"],handleQuery:[16],getUrlText:[16],query:[32],isQuerying:[32],isInitialLoading:[32],hasQueried:[32],icons:[32],kitMetadata:[32],fatalError:[32],familyStyles:[32],prefixToFamilyStyle:[32],selectedFamily:[32],selectedStyle:[32]}]]]],undefined)));const c=$("fa-icon-chooser")},858:(e,t,n)=>{n.d(t,{B:()=>s,C:()=>g,a:()=>S,b:()=>Be,e:()=>pe,f:()=>B,g:()=>he,h:()=>_,p:()=>v,r:()=>We,w:()=>u});const o="fa-icon-chooser",s={allRenderFn:!0,appendChildSlotFix:!1,asyncLoading:!0,asyncQueue:!1,attachStyles:!0,cloneNodeFix:!1,cmpDidLoad:!1,cmpDidRender:!1,cmpDidUnload:!1,cmpDidUpdate:!1,cmpShouldUpdate:!1,cmpWillLoad:!0,cmpWillRender:!1,cmpWillUpdate:!1,connectedCallback:!1,constructableCSS:!0,cssAnnotations:!0,cssVarShim:!1,devTools:!1,disconnectedCallback:!1,dynamicImportShim:!1,element:!1,event:!0,hasRenderFn:!0,hostListener:!1,hostListenerTarget:!1,hostListenerTargetBody:!1,hostListenerTargetDocument:!1,hostListenerTargetParent:!1,hostListenerTargetWindow:!1,hotModuleReplacement:!1,hydrateClientSide:!1,hydrateServerSide:!1,hydratedAttribute:!1,hydratedClass:!0,initializeNextTick:!1,invisiblePrehydration:!0,isDebug:!1,isDev:!0,isTesting:!0,lazyLoad:!0,lifecycle:!0,lifecycleDOMEvents:!0,member:!0,method:!1,mode:!1,observeAttribute:!0,profile:!1,prop:!0,propBoolean:!0,propMutable:!1,propNumber:!1,propString:!0,reflect:!1,safari10:!1,scoped:!1,scopedSlotTextContentFix:!1,scriptDataOpts:!1,shadowDelegatesFocus:!1,shadowDom:!0,shadowDomShim:!1,slot:!0,slotChildNodesFix:!1,slotRelocation:!1,state:!0,style:!0,svg:!0,taskQueue:!0,transformTagName:!1,updatable:!0,vdomAttribute:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomPropOrAttr:!0,vdomRef:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,vdomXlink:!0,watchCallback:!1};let l,a,r,i=0,$=!1,d=!1,c=!1,m=!1,h=null,p=0,f=!1;const u="undefined"!=typeof window?window:{},g=s.cssVarShim?u.CSS:null,y=u.document||{head:{}},v=(u.HTMLElement,{$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,o)=>e.addEventListener(t,n,o),rel:(e,t,n,o)=>e.removeEventListener(t,n,o),ce:(e,t)=>new CustomEvent(e,t)}),b=!s.shadowDomShim||!s.shadowDom||(()=>(y.head.attachShadow+"").indexOf("[native")>-1)(),w=(()=>{let e=!1;try{y.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(e){}return e})(),S=e=>Promise.resolve(e),N=!!s.constructableCSS&&(()=>{try{return new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replace}catch(e){}return!1})(),R=(e,t,n,o)=>{s.hostListener&&n&&(s.hostListenerTargetParent&&(n=o?n.filter((([e])=>32&e)):n.filter((([e])=>!(32&e)))),n.map((([n,o,l])=>{const a=s.hostListenerTarget?L(e,n):e,r=C(t,l),i=x(n);v.ael(a,o,r,i),(t.$rmListeners$=t.$rmListeners$||[]).push((()=>v.rel(a,o,r,i)))})))},C=(e,t)=>n=>{try{s.lazyLoad?256&e.$flags$?e.$lazyInstance$[t](n):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,n]):e.$hostElement$[t](n)}catch(e){qe(e)}},L=(e,t)=>s.hostListenerTargetDocument&&4&t?y:s.hostListenerTargetWindow&&8&t?u:s.hostListenerTargetBody&&16&t?y.body:s.hostListenerTargetParent&&32&t?e.parentElement:e,x=e=>w?{passive:!!(1&e),capture:!!(2&e)}:!!(2&e),T="s-id",k="sty-id",D="c-id",E="http://www.w3.org/1999/xlink",O=(e,t="")=>{if(s.profile&&performance.mark){const n=`st:${e}:${t}:${i++}`;return performance.mark(n),()=>performance.measure(`[Stencil] ${e}() <${t}>`,n)}return()=>{}},A=new WeakMap,P=(e,t,n)=>{let o=Ze.get(e);N&&n?(o=o||new CSSStyleSheet,o.replace(t)):o=t,Ze.set(e,o)},j=(e,t,n,o)=>{let l=M(t,n),a=Ze.get(l);if(!s.attachStyles)return l;if(e=11===e.nodeType?e:y,a)if("string"==typeof a){e=e.head||e;let n,r=A.get(e);if(r||A.set(e,r=new Set),!r.has(l)){if(s.hydrateClientSide&&e.host&&(n=e.querySelector(`[${k}="${l}"]`)))n.innerHTML=a;else{if(s.cssVarShim&&v.$cssShim$){n=v.$cssShim$.createHostStyle(o,l,a,!!(10&t.$flags$));const e=n["s-sc"];e&&(l=e,r=null)}else n=y.createElement("style"),n.innerHTML=a;(s.hydrateServerSide||s.hotModuleReplacement)&&n.setAttribute(k,l),e.insertBefore(n,e.querySelector("link"))}r&&r.add(l)}}else s.constructableCSS&&!e.adoptedStyleSheets.includes(a)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,a]);return l},M=(e,t)=>"sc-"+(s.mode&&t&&32&e.$flags$?e.$tagName$+"-"+t:e.$tagName$),z={},I=e=>"object"==(e=typeof e)||"function"===e,_=(e,t,...n)=>{let o=null,l=null,a=null,r=!1,i=!1,$=[];const d=t=>{for(let n=0;n<t.length;n++)o=t[n],Array.isArray(o)?d(o):null!=o&&"boolean"!=typeof o&&((r="function"!=typeof e&&!I(o))?o=String(o):s.isDev&&"function"!=typeof e&&void 0===o.$flags$&&Xe("vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects."),r&&i?$[$.length-1].$text$+=o:$.push(r?U(null,o):o),i=r)};if(d(n),t&&(s.isDev&&"input"===e&&Q(t),s.vdomKey&&t.key&&(l=t.key),s.slotRelocation&&t.name&&(a=t.name),s.vdomClass)){const e=t.className||t.class;e&&(t.class="object"!=typeof e?e:Object.keys(e).filter((t=>e[t])).join(" "))}if(s.isDev&&$.some(F)&&Xe("The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function."),s.vdomFunctional&&"function"==typeof e)return e(null===t?{}:t,$,H);const c=U(e,null);return c.$attrs$=t,$.length>0&&(c.$children$=$),s.vdomKey&&(c.$key$=l),s.slotRelocation&&(c.$name$=a),c},U=(e,t)=>{const n={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.vdomAttribute&&(n.$attrs$=null),s.vdomKey&&(n.$key$=null),s.slotRelocation&&(n.$name$=null),n},B={},F=e=>e&&e.$tag$===B,H={forEach:(e,t)=>e.map(W).forEach(t),map:(e,t)=>e.map(W).map(t).map(V)},W=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),V=e=>{if("function"==typeof e.vtag){const t=Object.assign({},e.vattrs);return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),_(e.vtag,t,...e.vchildren||[])}const t=U(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Q=e=>{const t=Object.keys(e),n=t.indexOf("value");if(-1===n)return;const o=t.indexOf("type"),s=t.indexOf("min"),l=t.indexOf("max"),a=t.indexOf("step");(n<o||n<s||n<l||n<a)&&Je('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},q=(e,t,n,o,l,a)=>{if(n!==o){let r=Qe(e,t),i=t.toLowerCase();if(s.vdomClass&&"class"===t){const t=e.classList,s=X(n),l=X(o);t.remove(...s.filter((e=>e&&!l.includes(e)))),t.add(...l.filter((e=>e&&!s.includes(e))))}else if(s.vdomStyle&&"style"===t){if(s.updatable)for(const t in n)o&&null!=o[t]||(!s.hydrateServerSide&&t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in o)n&&o[t]===n[t]||(!s.hydrateServerSide&&t.includes("-")?e.style.setProperty(t,o[t]):e.style[t]=o[t])}else if(s.vdomKey&&"key"===t);else if(s.vdomRef&&"ref"===t)o&&o(e);else if(!s.vdomListener||(s.lazyLoad?r:e.__lookupSetter__(t))||"o"!==t[0]||"n"!==t[1]){if(s.vdomPropOrAttr){const $=I(o);if((r||$&&null!==o)&&!l)try{if(e.tagName.includes("-"))e[t]=o;else{let s=null==o?"":o;"list"===t?r=!1:null!=n&&e[t]==s||(e[t]=s)}}catch(e){}let d=!1;s.vdomXlink&&i!==(i=i.replace(/^xlink\:?/,""))&&(t=i,d=!0),null==o||!1===o?!1===o&&""!==e.getAttribute(t)||(s.vdomXlink&&d?e.removeAttributeNS(E,t):e.removeAttribute(t)):(!r||4&a||l)&&!$&&(o=!0===o?"":o,s.vdomXlink&&d?e.setAttributeNS(E,t,o):e.setAttribute(t,o))}}else t="-"===t[2]?t.slice(3):Qe(u,i)?i.slice(2):i[2]+t.slice(3),n&&v.rel(e,t,n,!1),o&&v.ael(e,t,o,!1)}},K=/\s/,X=e=>e?e.split(K):[],J=(e,t,n,o)=>{const l=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,a=e&&e.$attrs$||z,r=t.$attrs$||z;if(s.updatable)for(o in a)o in r||q(l,o,a[o],void 0,n,t.$flags$);for(o in r)q(l,o,a[o],r[o],n,t.$flags$)},G=(e,t,n,o)=>{let i,d,h,p=t.$children$[n],f=0;if(s.slotRelocation&&!$&&(c=!0,"slot"===p.$tag$&&(l&&o.classList.add(l+"-s"),p.$flags$|=p.$children$?2:1)),s.isDev&&p.$elm$&&Xe(`The JSX ${null!==p.$text$?`"${p.$text$}" text`:`"${p.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),s.vdomText&&null!==p.$text$)i=p.$elm$=y.createTextNode(p.$text$);else if(s.slotRelocation&&1&p.$flags$)i=p.$elm$=s.isDebug||s.hydrateServerSide?ce(p):y.createTextNode("");else{if(s.svg&&!m&&(m="svg"===p.$tag$),i=p.$elm$=s.svg?y.createElementNS(m?"http://www.w3.org/2000/svg":"http://www.w3.org/1999/xhtml",s.slotRelocation&&2&p.$flags$?"slot-fb":p.$tag$):y.createElement(s.slotRelocation&&2&p.$flags$?"slot-fb":p.$tag$),s.svg&&m&&"foreignObject"===p.$tag$&&(m=!1),s.vdomAttribute&&J(null,p,m),(s.shadowDom||s.scoped)&&null!=l&&i["s-si"]!==l&&i.classList.add(i["s-si"]=l),p.$children$)for(f=0;f<p.$children$.length;++f)d=G(e,p,f,i),d&&i.appendChild(d);s.svg&&("svg"===p.$tag$?m=!1:"foreignObject"===i.tagName&&(m=!0))}return s.slotRelocation&&(i["s-hn"]=r,3&p.$flags$&&(i["s-sr"]=!0,i["s-cr"]=a,i["s-sn"]=p.$name$||"",h=e&&e.$children$&&e.$children$[n],h&&h.$tag$===p.$tag$&&e.$elm$&&Y(e.$elm$,!1))),i},Y=(e,t)=>{v.$flags$|=1;const n=e.childNodes;for(let e=n.length-1;e>=0;e--){const o=n[e];o["s-hn"]!==r&&o["s-ol"]&&(oe(o).insertBefore(o,ne(o)),o["s-ol"].remove(),o["s-ol"]=void 0,c=!0),t&&Y(o,t)}v.$flags$&=-2},Z=(e,t,n,o,l,a)=>{let i,$=s.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e;for(s.shadowDom&&$.shadowRoot&&$.tagName===r&&($=$.shadowRoot);l<=a;++l)o[l]&&(i=G(null,n,l,e),i&&(o[l].$elm$=i,$.insertBefore(i,s.slotRelocation?ne(t):t)))},ee=(e,t,n,o,l)=>{for(;t<=n;++t)(o=e[t])&&(l=o.$elm$,$e(o),s.slotRelocation&&(d=!0,l["s-ol"]?l["s-ol"].remove():Y(l,!0)),l.remove())},te=(e,t)=>e.$tag$===t.$tag$&&(s.slotRelocation&&"slot"===e.$tag$?e.$name$===t.$name$:!s.vdomKey||e.$key$===t.$key$),ne=e=>e&&e["s-ol"]||e,oe=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,se=(e,t)=>{const n=t.$elm$=e.$elm$,o=e.$children$,l=t.$children$,a=t.$tag$,r=t.$text$;let i;s.vdomText&&null!==r?s.vdomText&&s.slotRelocation&&(i=n["s-cr"])?i.parentNode.textContent=r:s.vdomText&&e.$text$!==r&&(n.data=r):(s.svg&&(m="svg"===a||"foreignObject"!==a&&m),(s.vdomAttribute||s.reflect)&&(s.slot&&"slot"===a||J(e,t,m)),s.updatable&&null!==o&&null!==l?((e,t,n,o)=>{let l,a,r=0,i=0,$=0,d=0,c=t.length-1,m=t[0],h=t[c],p=o.length-1,f=o[0],u=o[p];for(;r<=c&&i<=p;)if(null==m)m=t[++r];else if(null==h)h=t[--c];else if(null==f)f=o[++i];else if(null==u)u=o[--p];else if(te(m,f))se(m,f),m=t[++r],f=o[++i];else if(te(h,u))se(h,u),h=t[--c],u=o[--p];else if(te(m,u))!s.slotRelocation||"slot"!==m.$tag$&&"slot"!==u.$tag$||Y(m.$elm$.parentNode,!1),se(m,u),e.insertBefore(m.$elm$,h.$elm$.nextSibling),m=t[++r],u=o[--p];else if(te(h,f))!s.slotRelocation||"slot"!==m.$tag$&&"slot"!==u.$tag$||Y(h.$elm$.parentNode,!1),se(h,f),e.insertBefore(h.$elm$,m.$elm$),h=t[--c],f=o[++i];else{if($=-1,s.vdomKey)for(d=r;d<=c;++d)if(t[d]&&null!==t[d].$key$&&t[d].$key$===f.$key$){$=d;break}s.vdomKey&&$>=0?(a=t[$],a.$tag$!==f.$tag$?l=G(t&&t[i],n,$,e):(se(a,f),t[$]=void 0,l=a.$elm$),f=o[++i]):(l=G(t&&t[i],n,i,e),f=o[++i]),l&&(s.slotRelocation?oe(m.$elm$).insertBefore(l,ne(m.$elm$)):m.$elm$.parentNode.insertBefore(l,m.$elm$))}r>c?Z(e,null==o[p+1]?null:o[p+1].$elm$,n,o,i,p):s.updatable&&i>p&&ee(t,r,c)})(n,o,t,l):null!==l?(s.updatable&&s.vdomText&&null!==e.$text$&&(n.textContent=""),Z(n,null,t,l,0,l.length-1)):s.updatable&&null!==o&&ee(o,0,o.length-1),s.svg&&m&&"svg"===a&&(m=!1))},le=e=>{let t,n,o,s,l,a,r=e.childNodes;for(n=0,o=r.length;n<o;n++)if(t=r[n],1===t.nodeType){if(t["s-sr"])for(l=t["s-sn"],t.hidden=!1,s=0;s<o;s++)if(a=r[s].nodeType,r[s]["s-hn"]!==t["s-hn"]||""!==l){if(1===a&&l===r[s].getAttribute("slot")){t.hidden=!0;break}}else if(1===a||3===a&&""!==r[s].textContent.trim()){t.hidden=!0;break}le(t)}},ae=[],re=e=>{let t,n,o,s,l,a,r=0,i=e.childNodes,$=i.length;for(;r<$;r++){if(t=i[r],t["s-sr"]&&(n=t["s-cr"])&&n.parentNode)for(o=n.parentNode.childNodes,s=t["s-sn"],a=o.length-1;a>=0;a--)n=o[a],n["s-cn"]||n["s-nr"]||n["s-hn"]===t["s-hn"]||(ie(n,s)?(l=ae.find((e=>e.$nodeToRelocate$===n)),d=!0,n["s-sn"]=n["s-sn"]||s,l?l.$slotRefNode$=t:ae.push({$slotRefNode$:t,$nodeToRelocate$:n}),n["s-sr"]&&ae.map((e=>{ie(e.$nodeToRelocate$,n["s-sn"])&&(l=ae.find((e=>e.$nodeToRelocate$===n)),l&&!e.$slotRefNode$&&(e.$slotRefNode$=l.$slotRefNode$))}))):ae.some((e=>e.$nodeToRelocate$===n))||ae.push({$nodeToRelocate$:n}));1===t.nodeType&&re(t)}},ie=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,$e=e=>{s.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map($e))},de=(e,t)=>{const n=e.$hostElement$,o=e.$cmpMeta$,i=e.$vnode$||U(null,null),m=F(t)?t:_(null,null,t);if(r=n.tagName,s.isDev&&Array.isArray(t)&&t.some(F))throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of "${r.toLowerCase()}" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);if(s.reflect&&o.$attrsToReflect$&&(m.$attrs$=m.$attrs$||{},o.$attrsToReflect$.map((([e,t])=>m.$attrs$[t]=n[e]))),m.$tag$=null,m.$flags$|=4,e.$vnode$=m,m.$elm$=i.$elm$=s.shadowDom&&n.shadowRoot||n,(s.scoped||s.shadowDom)&&(l=n["s-sc"]),s.slotRelocation&&(a=n["s-cr"],$=b&&!!(1&o.$flags$),d=!1),se(i,m),s.slotRelocation){if(v.$flags$|=1,c){let e,t,n,o,l,a;re(m.$elm$);let r=0;for(;r<ae.length;r++)e=ae[r],t=e.$nodeToRelocate$,t["s-ol"]||(n=s.isDebug||s.hydrateServerSide?me(t):y.createTextNode(""),n["s-nr"]=t,t.parentNode.insertBefore(t["s-ol"]=n,t));for(r=0;r<ae.length;r++)if(e=ae[r],t=e.$nodeToRelocate$,e.$slotRefNode$){for(o=e.$slotRefNode$.parentNode,l=e.$slotRefNode$.nextSibling,n=t["s-ol"];n=n.previousSibling;)if(a=n["s-nr"],a&&a["s-sn"]===t["s-sn"]&&o===a.parentNode&&(a=a.nextSibling,!a||!a["s-nr"])){l=a;break}(!l&&o!==t.parentNode||t.nextSibling!==l)&&t!==l&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),o.insertBefore(t,l))}else 1===t.nodeType&&(t.hidden=!0)}d&&le(m.$elm$),v.$flags$&=-2,ae.length=0}},ce=e=>y.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${r.toLowerCase()})`),me=e=>y.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),he=e=>s.lazyLoad?He(e).$hostElement$:e,pe=(e,t,n)=>{const o=he(e);return{emit:e=>(s.isDev&&!o.isConnected&&Je(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),fe(o,t,{bubbles:!!(4&n),composed:!!(2&n),cancelable:!!(1&n),detail:e}))}},fe=(e,t,n)=>{const o=v.ce(t,n);return e.dispatchEvent(o),o},ue=(e,t)=>{s.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise((t=>e.$onRenderResolve$=t)))},ge=(e,t)=>{if(s.taskQueue&&s.updatable&&(e.$flags$|=16),s.asyncLoading&&4&e.$flags$)return void(e.$flags$|=512);ue(e,e.$ancestorComponent$);const n=()=>ye(e,t);return s.taskQueue?$t(n):n()},ye=(e,t)=>{const n=e.$hostElement$,o=O("scheduleUpdate",e.$cmpMeta$.$tagName$),l=s.lazyLoad?e.$lazyInstance$:n;let a;return t?(s.lazyLoad&&s.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map((([e,t])=>Ne(l,e,t))),e.$queuedListeners$=null)),Ce(n,"componentWillLoad"),s.cmpWillLoad&&(a=Ne(l,"componentWillLoad"))):(Ce(n,"componentWillUpdate"),s.cmpWillUpdate&&(a=Ne(l,"componentWillUpdate"))),Ce(n,"componentWillRender"),s.cmpWillRender&&(a=Re(a,(()=>Ne(l,"componentWillRender")))),o(),Re(a,(()=>ve(e,l,t)))},ve=async(e,t,n)=>{const o=e.$hostElement$,l=O("update",e.$cmpMeta$.$tagName$),a=o["s-rc"];s.style&&n&&(e=>{const t=e.$cmpMeta$,n=e.$hostElement$,o=t.$flags$,l=O("attachStyles",t.$tagName$),a=j(s.shadowDom&&b&&n.shadowRoot?n.shadowRoot:n.getRootNode(),t,e.$modeName$,n);(s.shadowDom||s.scoped)&&s.cssAnnotations&&10&o&&(n["s-sc"]=a,n.classList.add(a+"-h"),s.scoped&&2&o&&n.classList.add(a+"-s")),l()})(e);const r=O("render",e.$cmpMeta$.$tagName$);if(s.isDev&&(e.$flags$|=1024),s.hydrateServerSide?await be(e,t,o):be(e,t,o),s.cssVarShim&&v.$cssShim$&&v.$cssShim$.updateHost(o),s.isDev&&(e.$renderCount$++,e.$flags$&=-1025),s.hydrateServerSide)try{xe(o),n&&(1&e.$cmpMeta$.$flags$?o["s-en"]="":2&e.$cmpMeta$.$flags$&&(o["s-en"]="c"))}catch(e){qe(e,o)}if(s.asyncLoading&&a&&(a.map((e=>e())),o["s-rc"]=void 0),r(),l(),s.asyncLoading){const t=o["s-p"],n=()=>we(e);0===t.length?n():(Promise.all(t).then(n),e.$flags$|=4,t.length=0)}else we(e)},be=(e,t,n)=>{const o=!!s.allRenderFn,l=!!s.lazyLoad,a=!!s.taskQueue,r=!!s.updatable;try{if(h=t,t=(o||t.render)&&t.render(),r&&a&&(e.$flags$&=-17),(r||l)&&(e.$flags$|=2),s.hasRenderFn||s.reflect)if(s.vdomRender||s.reflect){if(s.hydrateServerSide)return Promise.resolve(t).then((t=>de(e,t)));de(e,t)}else n.textContent=t}catch(t){qe(t,e.$hostElement$)}return h=null,null},we=e=>{const t=e.$cmpMeta$.$tagName$,n=e.$hostElement$,o=O("postUpdate",t),l=s.lazyLoad?e.$lazyInstance$:n,a=e.$ancestorComponent$;s.cmpDidRender&&(s.isDev&&(e.$flags$|=1024),Ne(l,"componentDidRender"),s.isDev&&(e.$flags$&=-1025)),Ce(n,"componentDidRender"),64&e.$flags$?(s.cmpDidUpdate&&(s.isDev&&(e.$flags$|=1024),Ne(l,"componentDidUpdate"),s.isDev&&(e.$flags$&=-1025)),Ce(n,"componentDidUpdate"),o()):(e.$flags$|=64,s.asyncLoading&&s.cssAnnotations&&Le(n),s.cmpDidLoad&&(s.isDev&&(e.$flags$|=2048),Ne(l,"componentDidLoad"),s.isDev&&(e.$flags$&=-2049)),Ce(n,"componentDidLoad"),o(),s.asyncLoading&&(e.$onReadyResolve$(n),a||Se(t))),s.hotModuleReplacement&&n["s-hmr-load"]&&n["s-hmr-load"](),s.method&&s.lazyLoad&&e.$onInstanceResolve$(n),s.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),512&e.$flags$&&it((()=>ge(e,!1))),e.$flags$&=-517)},Se=e=>{s.cssAnnotations&&Le(y.documentElement),s.asyncQueue&&(v.$flags$|=2),it((()=>fe(u,"appload",{detail:{namespace:o}}))),s.profile&&performance.measure&&performance.measure(`[Stencil] ${o} initial load (by ${e})`,"st:app:start")},Ne=(e,t,n)=>{if(e&&e[t])try{return e[t](n)}catch(e){qe(e)}},Re=(e,t)=>e&&e.then?e.then(t):t(),Ce=(e,t)=>{s.lifecycleDOMEvents&&fe(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:o}})},Le=e=>s.hydratedClass?e.classList.add("hydrated"):s.hydratedAttribute?e.setAttribute("hydrated",""):void 0,xe=e=>{const t=e.children;if(null!=t)for(let e=0,n=t.length;e<n;e++){const n=t[e];"function"==typeof n.connectedCallback&&n.connectedCallback(),xe(n)}},Te=(e,t,n,o,l,a,r)=>{let i,$,d,c;if(1===a.nodeType){for(i=a.getAttribute(D),i&&($=i.split("."),$[0]!==r&&"0"!==$[0]||(d={$flags$:0,$hostId$:$[0],$nodeId$:$[1],$depth$:$[2],$index$:$[3],$tag$:a.tagName.toLowerCase(),$elm$:a,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push(d),a.removeAttribute(D),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,e=d,o&&"0"===d.$depth$&&(o[d.$index$]=d.$elm$))),c=a.childNodes.length-1;c>=0;c--)Te(e,t,n,o,l,a.childNodes[c],r);if(a.shadowRoot)for(c=a.shadowRoot.childNodes.length-1;c>=0;c--)Te(e,t,n,o,l,a.shadowRoot.childNodes[c],r)}else if(8===a.nodeType)$=a.nodeValue.split("."),$[1]!==r&&"0"!==$[1]||(i=$[0],d={$flags$:0,$hostId$:$[1],$nodeId$:$[2],$depth$:$[3],$index$:$[4],$elm$:a,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},"t"===i?(d.$elm$=a.nextSibling,d.$elm$&&3===d.$elm$.nodeType&&(d.$text$=d.$elm$.textContent,t.push(d),a.remove(),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,o&&"0"===d.$depth$&&(o[d.$index$]=d.$elm$))):d.$hostId$===r&&("s"===i?(d.$tag$="slot",$[5]?a["s-sn"]=d.$name$=$[5]:a["s-sn"]="",a["s-sr"]=!0,s.shadowDom&&o&&(d.$elm$=y.createElement(d.$tag$),d.$name$&&d.$elm$.setAttribute("name",d.$name$),a.parentNode.insertBefore(d.$elm$,a),a.remove(),"0"===d.$depth$&&(o[d.$index$]=d.$elm$)),n.push(d),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d):"r"===i&&(s.shadowDom&&o?a.remove():s.slotRelocation&&(l["s-cr"]=a,a["s-cn"]=!0))));else if(e&&"style"===e.$tag$){const t=U(null,a.textContent);t.$elm$=a,t.$index$="0",e.$children$=[t]}},ke=(e,t)=>{if(1===e.nodeType){let n=0;for(;n<e.childNodes.length;n++)ke(e.childNodes[n],t);if(e.shadowRoot)for(n=0;n<e.shadowRoot.childNodes.length;n++)ke(e.shadowRoot.childNodes[n],t)}else if(8===e.nodeType){const n=e.nodeValue.split(".");"o"===n[0]&&(t.set(n[1]+"."+n[2],e),e.nodeValue="",e["s-en"]=n[3])}},De=(e,t,n)=>{if(s.member&&t.$members$){s.watchCallback&&e.watchers&&(t.$watchers$=e.watchers);const o=Object.entries(t.$members$),l=e.prototype;if(o.map((([e,[o]])=>{(s.prop||s.state)&&(31&o||(!s.lazyLoad||2&n)&&32&o)?Object.defineProperty(l,e,{get(){return t=e,He(this).$instanceValues$.get(t);var t},set(l){if(s.isDev){const s=He(this);1&n||8&s.$flags$||!(31&o)||1024&o||Je(`@Prop() "${e}" on <${t.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`)}((e,t,n,o)=>{const l=He(e),a=s.lazyLoad?l.$hostElement$:e,r=l.$instanceValues$.get(t),i=l.$flags$,$=s.lazyLoad?l.$lazyInstance$:a;var d,c;if(d=n,c=o.$members$[t][0],n=null==d||I(d)?d:s.propBoolean&&4&c?"false"!==d&&(""===d||!!d):s.propNumber&&2&c?parseFloat(d):s.propString&&1&c?String(d):d,!(s.lazyLoad&&8&i&&void 0!==r||n===r)&&(l.$instanceValues$.set(t,n),s.isDev&&(1024&l.$flags$?Je(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,"\nElement",a,"\nNew value",n,"\nOld value",r):2048&l.$flags$&&Je(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,"\nElement",a,"\nNew value",n,"\nOld value",r)),!s.lazyLoad||$)){if(s.watchCallback&&o.$watchers$&&128&i){const e=o.$watchers$[t];e&&e.map((e=>{try{$[e](n,r,t)}catch(e){qe(e,a)}}))}if(s.updatable&&2==(18&i)){if(s.cmpShouldUpdate&&$.componentShouldUpdate&&!1===$.componentShouldUpdate(n,r,t))return;ge(l,!1)}}})(this,e,l,t)},configurable:!0,enumerable:!0}):s.lazyLoad&&s.method&&1&n&&64&o&&Object.defineProperty(l,e,{value(...t){const n=He(this);return n.$onInstancePromise$.then((()=>n.$lazyInstance$[e](...t)))}})})),s.observeAttribute&&(!s.lazyLoad||1&n)){const n=new Map;l.attributeChangedCallback=function(e,t,o){v.jmp((()=>{const t=n.get(e);if(this.hasOwnProperty(t))o=this[t],delete this[t];else if(l.hasOwnProperty(t)&&"number"==typeof this[t]&&this[t]==o)return;this[t]=(null!==o||"boolean"!=typeof this[t])&&o}))},e.observedAttributes=o.filter((([e,t])=>15&t[0])).map((([e,o])=>{const l=o[1]||e;return n.set(l,e),s.reflect&&512&o[0]&&t.$attrsToReflect$.push([e,l]),l}))}}return e},Ee=async(e,t,o,l,a)=>{if((s.lazyLoad||s.hydrateServerSide||s.style)&&!(32&t.$flags$)){if(s.lazyLoad||s.hydrateClientSide){if(t.$flags$|=32,(a=Ye(o,t,l)).then){const e=(r=`st:load:${o.$tagName$}:${t.$modeName$}`,i=`[Stencil] Load module for <${o.$tagName$}>`,s.profile&&performance.mark?(0===performance.getEntriesByName(r).length&&performance.mark(r),()=>{0===performance.getEntriesByName(i).length&&performance.measure(i,r)}):()=>{});a=await a,e()}if((s.isDev||s.isDebug)&&!a)throw new Error(`Constructor for "${o.$tagName$}#${t.$modeName$}" was not found`);s.member&&!a.isProxied&&(s.watchCallback&&(o.$watchers$=a.watchers),De(a,o,2),a.isProxied=!0);const e=O("createInstance",o.$tagName$);s.member&&(t.$flags$|=8);try{new a(t)}catch(e){qe(e)}s.member&&(t.$flags$&=-9),s.watchCallback&&(t.$flags$|=128),e(),Oe(t.$lazyInstance$)}else a=e.constructor,t.$flags$|=32,customElements.whenDefined(o.$tagName$).then((()=>t.$flags$|=128));if(s.style&&a.style){let l=a.style;s.mode&&"string"!=typeof l&&(l=l[t.$modeName$=(e=>et.map((t=>t(e))).find((e=>!!e)))(e)],s.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));const r=M(o,t.$modeName$);if(!Ze.has(r)){const e=O("registerStyles",o.$tagName$);!s.hydrateServerSide&&s.shadowDom&&s.shadowDomShim&&8&o.$flags$&&(l=await n.e(331).then(n.bind(n,3331)).then((e=>e.scopeCss(l,r,!1)))),P(r,l,!!(1&o.$flags$)),e()}}}var r,i;const $=t.$ancestorComponent$,d=()=>ge(t,!0);s.asyncLoading&&$&&$["s-rc"]?$["s-rc"].push(d):d()},Oe=e=>{s.lazyLoad&&s.connectedCallback&&Ne(e,"connectedCallback")},Ae=e=>{const t=e["s-cr"]=y.createComment(s.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},Pe=e=>{const t=e.cloneNode;e.cloneNode=function(e){const n=this,o=!!s.shadowDom&&n.shadowRoot&&b,l=t.call(n,!!o&&e);if(s.slot&&!o&&e){let e,t,o=0,a=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si"];for(;o<n.childNodes.length;o++)e=n.childNodes[o]["s-nr"],t=a.every((e=>!n.childNodes[o][e])),e&&(s.appendChildSlotFix&&l.__appendChild?l.__appendChild(e.cloneNode(!0)):l.appendChild(e.cloneNode(!0))),t&&l.appendChild(n.childNodes[o].cloneNode(!0))}return l}},je=e=>{e.__appendChild=e.appendChild,e.appendChild=function(e){const t=e["s-sn"]=Ie(e),n=_e(this.childNodes,t);if(n){const o=Ue(n,t),s=o[o.length-1];return s.parentNode.insertBefore(e,s.nextSibling)}return this.__appendChild(e)}},Me=(e,t)=>{if(s.scoped&&2&t.$flags$){const t=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(e,"__textContent",t),Object.defineProperty(e,"textContent",{get(){var e;const t=_e(this.childNodes,"");return 3===(null===(e=null==t?void 0:t.nextSibling)||void 0===e?void 0:e.nodeType)?t.nextSibling.textContent:t?t.textContent:this.__textContent},set(e){var t;const n=_e(this.childNodes,"");if(3===(null===(t=null==n?void 0:n.nextSibling)||void 0===t?void 0:t.nodeType))n.nextSibling.textContent=e;else if(n)n.textContent=e;else{this.__textContent=e;const t=this["s-cr"];t&&this.insertBefore(t,this.firstChild)}}})}},ze=(e,t)=>{class n extends Array{item(e){return this[e]}}if(8&t.$flags$){const t=e.__lookupGetter__("childNodes");Object.defineProperty(e,"children",{get(){return this.childNodes.map((e=>1===e.nodeType))}}),Object.defineProperty(e,"childElementCount",{get:()=>e.children.length}),Object.defineProperty(e,"childNodes",{get(){const e=t.call(this);if(!(1&v.$flags$)&&2&He(this).$flags$){const t=new n;for(let n=0;n<e.length;n++){const o=e[n]["s-nr"];o&&t.push(o)}return t}return n.from(e)}})}},Ie=e=>e["s-sn"]||1===e.nodeType&&e.getAttribute("slot")||"",_e=(e,t)=>{let n,o=0;for(;o<e.length;o++){if(n=e[o],n["s-sr"]&&n["s-sn"]===t)return n;if(n=_e(n.childNodes,t),n)return n}return null},Ue=(e,t)=>{const n=[e];for(;(e=e.nextSibling)&&e["s-sn"]===t;)n.push(e);return n},Be=(e,t={})=>{s.profile&&performance.mark&&performance.mark("st:app:start"),(()=>{if(s.devTools){const e=u.stencil=u.stencil||{},t=e.inspect;e.inspect=e=>{let n=(e=>{const t=He(e);if(!t)return;const n=t.$flags$,o=t.$hostElement$;return{renderCount:t.$renderCount$,flags:{hasRendered:!!(2&n),hasConnected:!!(1&n),isWaitingForChildren:!!(4&n),isConstructingInstance:!!(8&n),isQueuedForUpdate:!!(16&n),hasInitializedComponent:!!(32&n),hasLoadedComponent:!!(64&n),isWatchReady:!!(128&n),isListenReady:!!(256&n),needsRerender:!!(512&n)},instanceValues:t.$instanceValues$,ancestorComponent:t.$ancestorComponent$,hostElement:o,lazyInstance:t.$lazyInstance$,vnode:t.$vnode$,modeName:t.$modeName$,onReadyPromise:t.$onReadyPromise$,onReadyResolve:t.$onReadyResolve$,onInstancePromise:t.$onInstancePromise$,onInstanceResolve:t.$onInstanceResolve$,onRenderResolve:t.$onRenderResolve$,queuedListeners:t.$queuedListeners$,rmListeners:t.$rmListeners$,"s-id":o["s-id"],"s-cr":o["s-cr"],"s-lr":o["s-lr"],"s-p":o["s-p"],"s-rc":o["s-rc"],"s-sc":o["s-sc"]}})(e);return n||"function"!=typeof t||(n=t(e)),n}}})();const n=O("bootstrapLazy"),o=[],l=t.exclude||[],a=u.customElements,r=y.head,i=r.querySelector("meta[charset]"),$=y.createElement("style"),d=[],c=y.querySelectorAll(`[${k}]`);let m,h=!0,p=0;if(Object.assign(v,t),v.$resourcesUrl$=new URL(t.resourcesUrl||"./",y.baseURI).href,s.asyncQueue&&t.syncQueue&&(v.$flags$|=4),s.hydrateClientSide&&(v.$flags$|=2),s.hydrateClientSide&&s.shadowDom)for(;p<c.length;p++)P(c[p].getAttribute(k),c[p].innerHTML.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g,"$1{"),!0);e.map((e=>{e[1].map((n=>{const r={$flags$:n[0],$tagName$:n[1],$members$:n[2],$listeners$:n[3]};s.member&&(r.$members$=n[2]),s.hostListener&&(r.$listeners$=n[3]),s.reflect&&(r.$attrsToReflect$=[]),s.watchCallback&&(r.$watchers$={}),s.shadowDom&&!b&&1&r.$flags$&&(r.$flags$|=8);const i=s.transformTagName&&t.transformTagName?t.transformTagName(r.$tagName$):r.$tagName$,$=class extends HTMLElement{constructor(e){super(e),Ve(e=this,r),s.shadowDom&&1&r.$flags$&&(b?s.shadowDelegatesFocus?e.attachShadow({mode:"open",delegatesFocus:!!(16&r.$flags$)}):e.attachShadow({mode:"open"}):s.hydrateServerSide||"shadowRoot"in e||(e.shadowRoot=e)),s.slotChildNodesFix&&ze(e,r)}connectedCallback(){m&&(clearTimeout(m),m=null),h?d.push(this):v.jmp((()=>(e=>{if(!(1&v.$flags$)){const t=He(e),n=t.$cmpMeta$,o=O("connectedCallback",n.$tagName$);if(s.hostListenerTargetParent&&R(e,t,n.$listeners$,!0),1&t.$flags$)R(e,t,n.$listeners$,!1),Oe(t.$lazyInstance$);else{let o;if(t.$flags$|=1,s.hydrateClientSide&&(o=e.getAttribute(T),o)){if(s.shadowDom&&b&&1&n.$flags$){const t=s.mode?j(e.shadowRoot,n,e.getAttribute("s-mode")):j(e.shadowRoot,n);e.classList.remove(t+"-h",t+"-s")}((e,t,n,o)=>{const l=O("hydrateClient",t),a=e.shadowRoot,r=[],i=s.shadowDom&&a?[]:null,$=o.$vnode$=U(t,null);v.$orgLocNodes$||ke(y.body,v.$orgLocNodes$=new Map),e[T]=n,e.removeAttribute(T),Te($,r,[],i,e,e,n),r.map((e=>{const n=e.$hostId$+"."+e.$nodeId$,o=v.$orgLocNodes$.get(n),s=e.$elm$;o&&b&&""===o["s-en"]&&o.parentNode.insertBefore(s,o.nextSibling),a||(s["s-hn"]=t,o&&(s["s-ol"]=o,s["s-ol"]["s-nr"]=s)),v.$orgLocNodes$.delete(n)})),s.shadowDom&&a&&i.map((e=>{e&&a.appendChild(e)})),l()})(e,n.$tagName$,o,t)}if(s.slotRelocation&&!o&&(s.hydrateServerSide||(s.slot||s.shadowDom)&&12&n.$flags$)&&Ae(e),s.asyncLoading){let n=e;for(;n=n.parentNode||n.host;)if(s.hydrateClientSide&&1===n.nodeType&&n.hasAttribute("s-id")&&n["s-p"]||n["s-p"]){ue(t,t.$ancestorComponent$=n);break}}s.prop&&!s.hydrateServerSide&&n.$members$&&Object.entries(n.$members$).map((([t,[n]])=>{if(31&n&&e.hasOwnProperty(t)){const n=e[t];delete e[t],e[t]=n}})),s.initializeNextTick?it((()=>Ee(e,t,n))):Ee(e,t,n)}o()}})(this)))}disconnectedCallback(){v.jmp((()=>(e=>{if(!(1&v.$flags$)){const t=He(e),n=s.lazyLoad?t.$lazyInstance$:e;s.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map((e=>e())),t.$rmListeners$=void 0),s.cssVarShim&&v.$cssShim$&&v.$cssShim$.removeHost(e),s.lazyLoad&&s.disconnectedCallback&&Ne(n,"disconnectedCallback"),s.cmpDidUnload&&Ne(n,"componentDidUnload")}})(this)))}componentOnReady(){return He(this).$onReadyPromise$}};s.cloneNodeFix&&Pe($.prototype),s.appendChildSlotFix&&je($.prototype),s.hotModuleReplacement&&($.prototype["s-hmr"]=function(e){((e,t,n)=>{const o=He(e);o.$flags$=1,e["s-hmr-load"]=()=>{delete e["s-hmr-load"]},Ee(e,o,t,n)})(this,r,e)}),s.scopedSlotTextContentFix&&Me($.prototype,r),r.$lazyBundleId$=e[0],l.includes(i)||a.get(i)||(o.push(i),a.define(i,De($,r,1)))}))})),s.invisiblePrehydration&&(s.hydratedClass||s.hydratedAttribute)&&($.innerHTML=o+"{visibility:hidden}.hydrated{visibility:inherit}",$.setAttribute("data-styles",""),r.insertBefore($,i?i.nextSibling:r.firstChild)),h=!1,d.length?d.map((e=>e.connectedCallback())):s.profile?v.jmp((()=>m=setTimeout(Se,30,"timeout"))):v.jmp((()=>m=setTimeout(Se,30))),n()},Fe=new WeakMap,He=e=>Fe.get(e),We=(e,t)=>Fe.set(t.$lazyInstance$=e,t),Ve=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.isDev&&(n.$renderCount$=0),s.method&&s.lazyLoad&&(n.$onInstancePromise$=new Promise((e=>n.$onInstanceResolve$=e))),s.asyncLoading&&(n.$onReadyPromise$=new Promise((e=>n.$onReadyResolve$=e)),e["s-p"]=[],e["s-rc"]=[]),R(e,n,t.$listeners$,!1),Fe.set(e,n)},Qe=(e,t)=>t in e,qe=(e,t)=>(0,console.error)(e,t),Ke=s.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],Xe=(...e)=>console.error(...Ke,...e),Je=(...e)=>console.warn(...Ke,...e),Ge=new Map,Ye=(e,t,o)=>{const l=e.$tagName$.replace(/-/g,"_"),a=e.$lazyBundleId$;if(s.isDev&&"string"!=typeof a)return void Xe(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);const r=!s.hotModuleReplacement&&Ge.get(a);return r?r[l]:n(5500)(`./${a}.entry.js${s.hotModuleReplacement&&o?"?s-hmr="+o:""}`).then((e=>(s.hotModuleReplacement||Ge.set(a,e),e[l])),qe)},Ze=new Map,et=[],tt=[],nt=[],ot=[],st=(e,t)=>n=>{e.push(n),f||(f=!0,t&&4&v.$flags$?it(rt):v.raf(rt))},lt=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(e){qe(e)}e.length=0},at=(e,t)=>{let n=0,o=0;for(;n<e.length&&(o=performance.now())<t;)try{e[n++](o)}catch(e){qe(e)}n===e.length?e.length=0:0!==n&&e.splice(0,n)},rt=()=>{if(s.asyncQueue&&p++,lt(tt),s.asyncQueue){const e=2==(6&v.$flags$)?performance.now()+14*Math.ceil(.1*p):1/0;at(nt,e),at(ot,e),nt.length>0&&(ot.push(...nt),nt.length=0),(f=tt.length+nt.length+ot.length>0)?v.raf(rt):p=0}else lt(nt),(f=tt.length>0)&&v.raf(rt)},it=e=>S().then(e),$t=st(nt,!0);s.isDev,s.isTesting}}]);